CS 537 Programming Assignment 4 (Fall 2020)
Michael Noguera (noguera@cs.wisc.edu) and Julien de Castelnau (de-castelnau@cs.wisc.edu)
due 12/3 at 5:30pm

== BUILDING ==

To build, run "make" at the root of this directory. If you specify the DEBUG environment
variable as "true" or use "make DEBUG=true", debug symbols will be included in the 
executable as well. You can also run the scan-build target to build with the Clang static
analyzer, and scan-view to view the generated output in a web browser.

Use "make clean" to get rid of object files and executables.

== USAGE ==

Use ./pfsim-ALGORITHM TRACEFILE, where TRACEFILE is a valid tracefile format with a PID
and a VPN representing a memory reference on each line, and ALGORITHM is one of:
- FIFO: Uses FIFO replacement policy, wherein the first pages to be referenced are the first
		to be evicted when there is a need to pull in a new page and memory is full.
- LRU: Uses LRU replacement policy, wherein the pages with the longest time since their
		last references are evicted first.
- Clock: Implements the clock algorithm, which works by keeping track of reference bits
		for each page frame and evicting those that are still 0, whereby the only way for
		a reference bit to become 1 is by being referenced. As the clock algorithm finds 
		reference bits set to 0, it is also turning the 1s to 0s, requiring them to be
		referenced again in order to stay.
- Random: A basic reference policy which picks a literal random PPN from memory to evict.

Options:
	-m SIZE: If specified, sets a memory size of SIZE MBs. Default is 1MB if unspecified.
	-p SIZE: If specified, sets a page size of SIZE bytes. Default is 4096 if unspecified.

== PROJECT STRUCTURE ==

The functionality of pfsim is divided into seven logical modules, which serve the 
following tasks:

	- main: parses arguments and initiates program operation, mainly by calling into
		    simulator and trace_parser, then prints stats once simulation is complete.

	- trace_parser: Runs a first pass over the tracefile, collecting important info
					the simulator will use to jump around to different locations 
					in the tracefile. Parses the data into a runnable process queue,
					where each process has its location in the file noted using an
					interval tree, decorated with ftell'd file locations.

	- intervaltree: Implementation of the aforementioned intervaltree with search, 
				    insert, and print operations supported.

	- memory: This module handles everything related to physical memory transactions:
			  the allocation of an array representing memory, loading/eviction of a page
			  and an an implementation of a shadow array freelist to go along with it
			  (indicating which pages are free). 

	- process: This module handles everything related to processes and virtual memory:
				creation/destruction of processes, switching between process queues
				where they are held, and an implementation for each process' page table. 
				Provides functions for callers to easily map VPN,PID->PPN through its 
				page table. Several different queues are stored, including one for 
				runnable+running processes, one for blocked processes (waiting on disk I/O), 
				and one for finished processes.
	
	- simulator: Orchestrates and oversees all aspects of the simulation,
				given properly parsed process data. Handles page faults, page hits,
				and calls into the replacement module when needed, and runs each process
				in order. Calls into stat to update the statistics whenever certain events
				occur (page hits, page faults, etc).

	- replace: A module with one job: to be able to give a PPN (unsigned long) to evict,
			   when memory is full. The header for this file is defined with the common 
			   triggers that we found our algorithms needed to be updated, such as whenever 
			   a page hit occurs, or whenever a page fault happens and the disk I/O completes. 
			   More or less, the function Replace_getPageToEvict serves as the implementation
			   for a given algorithm. The algorithms that implement this header file and 
			   their details are described above.
	
	- stat: Handles the tracking of the following statistics: average memory usage, average
		    runnable processes, total memory references, and total page faults. The simulator
			keeps track of the running time, which is passed to stat when it needs to print
			statistics. Stat defines some functions for when certain events occur, those being
			Stat_hit and Stat_miss for when a page hit or miss happens respectively. A "nothing
			special happened for this tick" function also exists, in the form of Stat_default, in
			case time passed (where certain fields will still need to be updated) but nothing of 
			interest happened. Simulator calls this function every tick, or every X number of ticks
			when X ticks were "skipped" when all procs were blocked.
		
	
====================================================================================
NOTES

1 | 12 6
2 | 12 7
3 | 12 8
4 | 42 303
5 | 12 1
6 | 42 303

reactivated processes come back from the i/o queue

bottlenecks:
1. having to traverse large skipped ranges
2. traversing file numerous times (the initial pass)

QUEUES:
enum ProcessState { RUNNING, WAITING (scheduler), BLOCKED (I/O), NOTSTARTED, FINISHED };

make a queue for each state:
NOTSTARTED:
RUNNING:
WAITING:
BLOCKED:
FINISHED:

PAGES
- - ---------------------------------------------------------------------------------------------------------- - -
    ...|ppn,pnode,vpn,pid,vnode,overhead|ppn,pnode,vpn,pid,vnode,overhead|ppn,pnode,vpn,pid,vnode,overhead|...
- - ---------------------------------------------------------------------------------------------------------- - -
^*page

PROCESSES
---------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------


Process representation
	typedef struct process_t {
	    long pid; // identifies this process overall
	    ProcessState state;
	    unsigned int waiting;
	    unsigned long firstline;
	    unsigned long currentline;
	    unsigned long nextknownline;
	    unsigned long lastline;
	    VAS vas;
	} Process;
Page representation
	typedef struct page_t {
	    long ppn;    // physical page number
	    void* pnode; // pointer to a node in the ppn-keyed tree, used for reverse
	                 // page resolution (ppn->page)
	    long vpn;    // virtual page number
	    long pid;    // process id
	    void* vnode; // pointer to a node in the vpn-keyed tree. there is one of
	                 // these trees per process. used for forward page resolution
	                 // (vpn->page)
	    void* overhead;
	} Page;
page table "VAS"
PAS (arr. of pages) (inverted page table)
run order queue - processes are sorted by starting line number (queue)
disk I/O wait queue - for processes waiting on I/O

.==============================================================================.
| 1. FIRST PASS                                                          DONE! |
'------------------------------------------------------------------------------'

PARSER RUNS
provide a 1d sorted (by PID) array of Processes

If first time pid seen:
	Allocate NEW process struct
	pid = (known)
	state = NOTSTARTED
	firstline = (known) <set to 0 at first, then on each occurance if zero, set to line>
	 -> if firstline was just set, enqueue proc on run order queue (automatically in order, because parsing line by line)
	currentline = firstline
	lastline = (known) <set to currentline's value at EOF>
	vas = NULL
If process already exists (this pid seen before):
	lastline = current line in file traversal

.------------------
| Post-first-pass:
| - Process structs created
| - interval tree
| - list of all processes
'------------------

.==============================================================================.
| 2. MAIN LOOP                                                                 |
'------------------------------------------------------------------------------'
have a queue of Process structs (know first line, last line, PID) -> run queue
main-scoped variable "curr" points to the currently running process
mem-module static-scoped free list
-------

Is there a process at the front of the disk wait queue?
Yes-> decrement its counter
      if it's ready to run:
      	1. load the ready process's page into memory
      		- if memory is full, replace
      	2. insert the current process to the corresponding spot in priority queue based on line number
      	3. curr = the ready process
No -> continue

Is there a currently running process? (some variable Process curr in main)
Yes-> continue
No -> get the next process from the priority queue (if none next, exit)

assert we have a process to run

curr->currentline = get next current line

Does a page struct exist?
No -> how to create?
Yes:
Is the page in memory?
Yes-> continue // page table hit
No -> PAGE FAULT
		Add this process to the I/O queue (& set status to WAITING)
		needs to wait for 2ms penalty because 

		ppn determined by a main-scoped counter (begin assigning in middle then alternate sides with modulo, b/c avl-backed table)

assert we have a page that has been accessed

tell stat to update statistics
tell replace that there was a hit

increment time counter

continue to start of loop

.==============================================================================.
| 3. EXIT                                                                      |
'------------------------------------------------------------------------------'
print stats and exit with EXIT_SUCCESS



